{
  "type": "nodegraph-data",
  "nodes": [
    {
      "id": "771d6de6-f7fa-4b0d-8aac-ee75da1b4a7f",
      "label": "Manifest",
      "type": "manifest",
      "position": {
        "x": -260,
        "y": -160
      },
      "width": 360,
      "height": 220,
      "data": {
        "identity": {
          "graphId": "4db2dc99-bc8d-41dc-a883-48937b5d2ffb",
          "name": "DomainMemoryFactory",
          "version": "0.1.0",
          "description": "",
          "createdAt": "2026-02-12T17:26:05.370Z",
          "updatedAt": "2026-02-12T17:26:05.370Z"
        },
        "intent": {
          "kind": "graph",
          "scope": "mixed"
        },
        "dependencies": {
          "nodeTypes": [
            "manifest",
            "legend",
            "dictionary",
            "default",
            "markdown"
          ],
          "portContracts": [
            "core"
          ],
          "skills": [],
          "schemaVersions": {
            "nodes": ">=1.0.0",
            "ports": ">=1.0.0"
          },
          "optional": []
        },
        "authority": {
          "mutation": {
            "allowCreate": true,
            "allowUpdate": true,
            "allowDelete": true,
            "appendOnly": false
          },
          "actors": {
            "humans": true,
            "agents": true,
            "tools": true
          },
          "styleAuthority": "descriptive",
          "history": {
            "rewriteAllowed": false,
            "squashAllowed": false
          }
        },
        "document": {
          "url": ""
        },
        "settings": {
          "theme": null,
          "backgroundImage": null,
          "defaultNodeColor": "#1976d2",
          "defaultEdgeColor": "#666666",
          "snapToGrid": false,
          "gridSize": 20,
          "edgeRouting": "auto",
          "layout": null,
          "github": {
            "repo": "",
            "path": "",
            "branch": "main"
          },
          "autoSave": false
        }
      }
    },
    {
      "id": "dmf-goal",
      "type": "markdown",
      "label": "Thesis",
      "position": {
        "x": -40,
        "y": -320
      },
      "width": 660,
      "height": 220,
      "visible": true,
      "showLabel": true,
      "data": {
        "markdown": "## Domain Memory Factory (Agents)\n**Thesis:** long-running agents fail when they are *amnesiac*. The fix is not a smarter model — it’s **durable domain memory** + a **harness ritual** that forces disciplined progress.\n\nTwilite turns domain memory into a shareable artifact: a persistent `.node` graph that evolves by validated deltas."
      }
    },
    {
      "id": "dmf-problem",
      "type": "markdown",
      "label": "Problem",
      "position": {
        "x": -40,
        "y": -70
      },
      "width": 660,
      "height": 260,
      "visible": true,
      "showLabel": true,
      "data": {
        "markdown": "## The Problem with “General Agents”\n- Context windows reset → agent becomes an amnesiac with tools\n- Long-horizon work degrades into:\n  - manic bursts that fail\n  - wandering partial progress\n  - false success reports\n- Without durable state, each run re-derives “definition of done”"
      }
    },
    {
      "id": "dmf-solution",
      "type": "markdown",
      "label": "Solution",
      "position": {
        "x": 700,
        "y": -70
      },
      "width": 660,
      "height": 260,
      "visible": true,
      "showLabel": true,
      "data": {
        "markdown": "## Solution: Domain Memory as Structured State\nDomain memory is not “a vector DB lookup.”\n\nIt is a **persistent structured representation** of:\n- goals and backlog\n- constraints and requirements\n- status (passing/failing/blocked)\n- what was tried, what broke, what was reverted\n- rituals: how to run, test, deploy, extend\n\nThe agent becomes a policy that transforms one memory state into the next."
      }
    },
    {
      "id": "dmf-pattern",
      "type": "markdown",
      "label": "Two-Agent Pattern",
      "position": {
        "x": -40,
        "y": 220
      },
      "width": 660,
      "height": 300,
      "visible": true,
      "showLabel": true,
      "data": {
        "markdown": "## Two-Agent Pattern (Initializer → Worker)\nNot about personalities — about who owns memory.\n\n- **Initializer:** expands the prompt into memory artifacts (feature list, rules, scaffolding)\n- **Worker:** reads memory, picks one item, makes small testable progress, updates memory, commits, exits\n\nEvery run starts the same way: **read memory → verify state → act**."
      }
    },
    {
      "id": "dmf-Twilite-fit",
      "type": "markdown",
      "label": "Why Twilite",
      "position": {
        "x": 700,
        "y": 240
      },
      "width": 660,
      "height": 320,
      "visible": true,
      "showLabel": true,
      "data": {
        "markdown": "## Why Twilite Fits This Perfectly\nTwilite provides the domain memory artifact and the harness:\n\n- `.node` graphs are **durable memory** (portable + shareable)\n- LLMs emit **validated deltas** (create/update/delete), not overwriting snapshots\n- History/timeline/milestones record state transitions\n- Autolayout/routing makes minimal payloads readable\n- Git/GitHub workflows make progress reviewable\n\nMoat = memory schema + harness + workflows, not a proprietary model."
      }
    },
    {
      "id": "dmf-ritual",
      "type": "markdown",
      "label": "Boot Ritual",
      "position": {
        "x": -40,
        "y": 560
      },
      "width": 660,
      "height": 300,
      "visible": true,
      "showLabel": true,
      "data": {
        "markdown": "## Boot Ritual (Session Discipline)\nA serious run follows a ritual:\n\n1. Read the graph memory (goal, backlog, constraints)\n2. Read history (timeline / Git commits)\n3. Select one atomic target (a failing feature or open question)\n4. Execute small changes + validate\n5. Update memory (status + notes)\n6. Commit / milestone\n\nThis turns “LLM calls” into durable progress."
      }
    },
    {
      "id": "dmf-next",
      "type": "markdown",
      "label": "What To Build",
      "position": {
        "x": 700,
        "y": 600
      },
      "width": 660,
      "height": 320,
      "visible": true,
      "showLabel": true,
      "data": {
        "markdown": "## What To Build in Twilite (Domain Memory Factory)\n- Templates: backlog/status/constraints nodes\n- Commands: create/update flows that preserve IDs\n- Validation: prevent overwrite-by-snapshot\n- Checkpoints: timeline milestones + commit hooks\n- Live docs: reload/watch so memory stays current\n\nResult: agents behave like disciplined engineers, not autocomplete."
      }
    }
  ],
  "edges": [
    {
      "id": "dmf-e1",
      "type": "child",
      "source": "dmf-goal",
      "target": "dmf-problem",
      "label": "problem",
      "sourcePort": "root",
      "targetPort": "root"
    },
    {
      "id": "dmf-e2",
      "type": "child",
      "source": "dmf-problem",
      "target": "dmf-solution",
      "label": "requires",
      "sourcePort": "root",
      "targetPort": "root"
    },
    {
      "id": "dmf-e3",
      "type": "child",
      "source": "dmf-solution",
      "target": "dmf-pattern",
      "label": "pattern",
      "sourcePort": "root",
      "targetPort": "root"
    },
    {
      "id": "dmf-e4",
      "type": "child",
      "source": "dmf-pattern",
      "target": "dmf-Twilite-fit",
      "label": "implemented by",
      "sourcePort": "root",
      "targetPort": "root"
    },
    {
      "id": "dmf-e5",
      "type": "child",
      "source": "dmf-Twilite-fit",
      "target": "dmf-ritual",
      "label": "ritual",
      "sourcePort": "root",
      "targetPort": "root"
    },
    {
      "id": "dmf-e6",
      "type": "child",
      "source": "dmf-ritual",
      "target": "dmf-next",
      "label": "build next",
      "sourcePort": "root",
      "targetPort": "root"
    }
  ],
  "timestamp": "2025-12-28T00:00:00.000Z",
  "nodeCount": 7,
  "edgeCount": 6
}